#!/usr/bin/env python3
"""

   pytic

   Copyright 2014 2018 Dan Tyrrell

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

   Class for the tic stepper drivers.

    #basic comms

    # list_connected_devices()
    # handle_open()
    # list_free()
    # handle_close()
    # device_free()

    #position or speed of a stepper motor over USB,

    # exit_safe_start()
    # set_target_speed()
    # get_target_position()

    # status

    # get_variables()
    # variables_free()

    # change the settings

    # get_settings()
    # set_settings()
    # restore_defaults()
    # reinitialize()
    # settings_free()

    #/// - error_get_message()
    #/// - error_has_code()
    #/// - error_free()


"""

import usb.core
import usb.util
import usb.control
import logging

logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s.%(msecs)d-%(name)s-%(threadName)s-%(levelname)s %(message)s',
                    datefmt='%M:%S')
log = logging.getLogger(__name__)

TIC_PRODUCT_T825 = 1
TIC_PRODUCT_T834 = 2
TIC_PRODUCT_T500 = 3
# Generated by h2py from /home/dan/Documents/pololu-tic-software/include/tic_protocol.h
TIC_VENDOR_ID = 0x1FFB
TIC_PRODUCT_ID_T825 = 0x00B3
TIC_PRODUCT_ID_T834 = 0x00B5
TIC_PRODUCT_ID_T500 = 0x00BD

TIC_FIRMWARE_MODIFICATION_STRING_INDEX = 4

TIC_OPERATION_STATE_RESET = 0
TIC_OPERATION_STATE_DEENERGIZED = 2
TIC_OPERATION_STATE_SOFT_ERROR = 4
TIC_OPERATION_STATE_WAITING_FOR_ERR_LINE = 6
TIC_OPERATION_STATE_STARTING_UP = 8
TIC_OPERATION_STATE_NORMAL = 10

TIC_MISC_FLAGS1_ENERGIZED = 0
TIC_MISC_FLAGS1_POSITION_UNCERTAIN = 1

TIC_ERROR_INTENTIONALLY_DEENERGIZED = 0
TIC_ERROR_MOTOR_DRIVER_ERROR = 1
TIC_ERROR_LOW_VIN = 2
TIC_ERROR_KILL_SWITCH = 3
TIC_ERROR_REQUIRED_INPUT_INVALID = 4
TIC_ERROR_SERIAL_ERROR = 5
TIC_ERROR_COMMAND_TIMEOUT = 6
TIC_ERROR_SAFE_START_VIOLATION = 7
TIC_ERROR_ERR_LINE_HIGH = 8
TIC_ERROR_SERIAL_FRAMING = 16
TIC_ERROR_SERIAL_RX_OVERRUN = 17
TIC_ERROR_SERIAL_FORMAT = 18
TIC_ERROR_SERIAL_CRC = 19
TIC_ERROR_ENCODER_SKIP = 20

TIC_INPUT_STATE_NOT_READY = 0
TIC_INPUT_STATE_INVALID = 1
TIC_INPUT_STATE_HALT = 2
TIC_INPUT_STATE_POSITION = 3
TIC_INPUT_STATE_VELOCITY = 4

TIC_RESPONSE_DEENERGIZE = 0
TIC_RESPONSE_HALT_AND_HOLD = 1
TIC_RESPONSE_DECEL_TO_HOLD = 2
TIC_RESPONSE_GO_TO_POSITION = 3

TIC_PIN_NUM_SCL = 0
TIC_PIN_NUM_SDA = 1
TIC_PIN_NUM_TX = 2
TIC_PIN_NUM_RX = 3
TIC_PIN_NUM_RC = 4

TIC_PLANNING_MODE_OFF = 0
TIC_PLANNING_MODE_TARGET_POSITION = 1
TIC_PLANNING_MODE_TARGET_VELOCITY = 2

TIC_RESET_POWER_UP = 0
TIC_RESET_BROWNOUT = 1
TIC_RESET_RESET_LINE = 2
TIC_RESET_WATCHDOG = 4
TIC_RESET_SOFTWARE = 8
TIC_RESET_STACK_OVERFLOW = 16
TIC_RESET_STACK_UNDERFLOW = 32

TIC_PIN_STATE_HIGH_IMPEDANCE = 0
TIC_PIN_STATE_PULLED_UP = 1
TIC_PIN_STATE_OUTPUT_LOW = 2
TIC_PIN_STATE_OUTPUT_HIGH = 3

TIC_MIN_ALLOWED_BAUD_RATE = 200
TIC_MAX_ALLOWED_BAUD_RATE = 115385

TIC_DEFAULT_COMMAND_TIMEOUT = 1000
TIC_MAX_ALLOWED_COMMAND_TIMEOUT = 60000

TIC_MAX_ALLOWED_CURRENT = 3968
TIC_MAX_ALLOWED_CURRENT_T825 = 3968
TIC_MAX_ALLOWED_CURRENT_T834 = 3456
TIC_MAX_ALLOWED_CURRENT_T500 = 3093
TIC_MAX_ALLOWED_CURRENT_CODE_T500 = 32
TIC_CURRENT_LIMIT_UNITS_MA = 32

TIC_MIN_ALLOWED_ACCEL = 100
TIC_MAX_ALLOWED_ACCEL = 0x7FFFFFFF
TIC_MAX_ALLOWED_SPEED = 500000000

TIC_MAX_ALLOWED_ENCODER_PRESCALER = 0x7FFFFFFF
TIC_MAX_ALLOWED_ENCODER_POSTSCALER = 0x7FFFFFFF

TIC_SPEED_UNITS_PER_HZ = 10000
TIC_ACCEL_UNITS_PER_HZ2 = 100

TIC_CONTROL_MODE_SERIAL = 0
TIC_CONTROL_MODE_STEP_DIR = 1
TIC_CONTROL_MODE_RC_POSITION = 2
TIC_CONTROL_MODE_RC_SPEED = 3
TIC_CONTROL_MODE_ANALOG_POSITION = 4
TIC_CONTROL_MODE_ANALOG_SPEED = 5
TIC_CONTROL_MODE_ENCODER_POSITION = 6
TIC_CONTROL_MODE_ENCODER_SPEED = 7

TIC_SCALING_DEGREE_LINEAR = 0
TIC_SCALING_DEGREE_QUADRATIC = 1
TIC_SCALING_DEGREE_CUBIC = 2

TIC_STEP_MODE_FULL = 0
TIC_STEP_MODE_HALF = 1
TIC_STEP_MODE_MICROSTEP1 = 0
TIC_STEP_MODE_MICROSTEP2 = 1
TIC_STEP_MODE_MICROSTEP4 = 2
TIC_STEP_MODE_MICROSTEP8 = 3
TIC_STEP_MODE_MICROSTEP16 = 4
TIC_STEP_MODE_MICROSTEP32 = 5

TIC_DECAY_MODE_MIXED = 0
TIC_DECAY_MODE_SLOW = 1
TIC_DECAY_MODE_FAST = 2
TIC_DECAY_MODE_MODE3 = 3
TIC_DECAY_MODE_MODE4 = 4
TIC_DECAY_MODE_T825_MIXED = 0
TIC_DECAY_MODE_T825_SLOW = 1
TIC_DECAY_MODE_T825_FAST = 2
TIC_DECAY_MODE_T834_MIXED50 = 0
TIC_DECAY_MODE_T834_SLOW = 1
TIC_DECAY_MODE_T834_FAST = 2
TIC_DECAY_MODE_T834_MIXED25 = 3
TIC_DECAY_MODE_T834_MIXED75 = 4
TIC_DECAY_MODE_T500_AUTO = 0

TIC_PIN_PULLUP = 7
TIC_PIN_ANALOG = 6

TIC_PIN_FUNC_POSN = 0
TIC_PIN_FUNC_MASK = 0x0F
TIC_PIN_FUNC_DEFAULT = 0
TIC_PIN_FUNC_USER_IO = 1
TIC_PIN_FUNC_USER_INPUT = 2
TIC_PIN_FUNC_POT_POWER = 3
TIC_PIN_FUNC_SERIAL = 4
TIC_PIN_FUNC_RC = 5
TIC_PIN_FUNC_ENCODER = 6
TIC_PIN_FUNC_KILL_SWITCH = 7

TIC_CMD_SET_TARGET_POSITION = 0xE0
TIC_CMD_SET_TARGET_VELOCITY = 0xE3
TIC_CMD_HALT_AND_SET_POSITION = 0xEC
TIC_CMD_HALT_AND_HOLD = 0x89
TIC_CMD_RESET_COMMAND_TIMEOUT = 0x8C
TIC_CMD_DEENERGIZE = 0x86
TIC_CMD_ENERGIZE = 0x85
TIC_CMD_EXIT_SAFE_START = 0x83
TIC_CMD_ENTER_SAFE_START = 0x8F
TIC_CMD_RESET = 0xB0
TIC_CMD_CLEAR_DRIVER_ERROR = 0x8A
TIC_CMD_SET_MAX_SPEED = 0xE6
TIC_CMD_SET_STARTING_SPEED = 0xE5
TIC_CMD_SET_MAX_ACCEL = 0xEA
TIC_CMD_SET_MAX_DECEL = 0xE9
TIC_CMD_SET_STEP_MODE = 0x94
TIC_CMD_SET_CURRENT_LIMIT = 0x91
TIC_CMD_SET_DECAY_MODE = 0x92
TIC_CMD_GET_VARIABLE = 0xA1
TIC_CMD_GET_VARIABLE_AND_CLEAR_ERRORS_OCCURRED = 0xA2
TIC_CMD_GET_SETTING = 0xA8
TIC_CMD_SET_SETTING = 0x13
TIC_CMD_REINITIALIZE = 0x10
TIC_CMD_START_BOOTLOADER = 0xFF
TIC_CMD_GET_DEBUG_DATA = 0x20

# offsets/indexes
TIC_VAR_OPERATION_STATE = 0x00
TIC_VAR_MISC_FLAGS1 = 0x01
TIC_VAR_ERROR_STATUS = 0x02
TIC_VAR_ERRORS_OCCURRED = 0x04
TIC_VAR_PLANNING_MODE = 0x09
TIC_VAR_TARGET_POSITION = 0x0A
TIC_VAR_TARGET_VELOCITY = 0x0E
TIC_VAR_STARTING_SPEED = 0x12
TIC_VAR_MAX_SPEED = 0x16
TIC_VAR_MAX_DECEL = 0x1A
TIC_VAR_MAX_ACCEL = 0x1E
TIC_VAR_CURRENT_POSITION = 0x22
TIC_VAR_CURRENT_VELOCITY = 0x26
TIC_VAR_ACTING_TARGET_POSITION = 0x2A
TIC_VAR_TIME_SINCE_LAST_STEP = 0x2E
TIC_VAR_DEVICE_RESET = 0x32
TIC_VAR_VIN_VOLTAGE = 0x33
TIC_VAR_UP_TIME = 0x35
TIC_VAR_ENCODER_POSITION = 0x39
TIC_VAR_RC_PULSE_WIDTH = 0x3D
TIC_VAR_ANALOG_READING_SCL = 0x3F
TIC_VAR_ANALOG_READING_SDA = 0x41
TIC_VAR_ANALOG_READING_TX = 0x43
TIC_VAR_ANALOG_READING_RX = 0x45
TIC_VAR_DIGITAL_READINGS = 0x47
TIC_VAR_PIN_STATES = 0x48
TIC_VAR_STEP_MODE = 0x49
TIC_VAR_CURRENT_LIMIT = 0x4A
TIC_VAR_DECAY_MODE = 0x4B
TIC_VAR_INPUT_STATE = 0x4C
TIC_VAR_INPUT_AFTER_AVERAGING = 0x4D
TIC_VAR_INPUT_AFTER_HYSTERESIS = 0x4F
TIC_VAR_INPUT_AFTER_SCALING = 0x51

TIC_VARIABLES_SIZE = 0x55

# indexes
TIC_SETTING_NOT_INITIALIZED = 0x00
TIC_SETTING_CONTROL_MODE = 0x01
TIC_SETTING_NEVER_SLEEP = 0x02
TIC_SETTING_DISABLE_SAFE_START = 0x03
TIC_SETTING_IGNORE_ERR_LINE_HIGH = 0x04
TIC_SETTING_SERIAL_BAUD_RATE_GENERATOR = 0x05
TIC_SETTING_SERIAL_DEVICE_NUMBER = 0x07
TIC_SETTING_AUTO_CLEAR_DRIVER_ERROR = 0x08
TIC_SETTING_COMMAND_TIMEOUT = 0x09
TIC_SETTING_SERIAL_CRC_ENABLED = 0x0B
TIC_SETTING_LOW_VIN_TIMEOUT = 0x0C
TIC_SETTING_LOW_VIN_SHUTOFF_VOLTAGE = 0x0E
TIC_SETTING_LOW_VIN_STARTUP_VOLTAGE = 0x10
TIC_SETTING_HIGH_VIN_SHUTOFF_VOLTAGE = 0x12
TIC_SETTING_VIN_CALIBRATION = 0x14
TIC_SETTING_RC_MAX_PULSE_PERIOD = 0x16
TIC_SETTING_RC_BAD_SIGNAL_TIMEOUT = 0x18
TIC_SETTING_RC_CONSECUTIVE_GOOD_PULSES = 0x1A
TIC_SETTING_INVERT_MOTOR_DIRECTION = 0x1B
TIC_SETTING_INPUT_ERROR_MIN = 0x1C
TIC_SETTING_INPUT_ERROR_MAX = 0x1E
TIC_SETTING_INPUT_SCALING_DEGREE = 0x20
TIC_SETTING_INPUT_INVERT = 0x21
TIC_SETTING_INPUT_MIN = 0x22
TIC_SETTING_INPUT_NEUTRAL_MIN = 0x24
TIC_SETTING_INPUT_NEUTRAL_MAX = 0x26
TIC_SETTING_INPUT_MAX = 0x28
TIC_SETTING_OUTPUT_MIN = 0x2A
TIC_SETTING_INPUT_AVERAGING_ENABLED = 0x2E
TIC_SETTING_INPUT_HYSTERESIS = 0x2F
TIC_SETTING_CURRENT_LIMIT_DURING_ERROR = 0x31
TIC_SETTING_OUTPUT_MAX = 0x32
TIC_SETTING_SWITCH_POLARITY_MAP = 0x36
TIC_SETTING_ENCODER_POSTSCALER = 0x37
TIC_SETTING_SCL_CONFIG = 0x3B
TIC_SETTING_SDA_CONFIG = 0x3C
TIC_SETTING_TX_CONFIG = 0x3D
TIC_SETTING_RX_CONFIG = 0x3E
TIC_SETTING_RC_CONFIG = 0x3F
TIC_SETTING_CURRENT_LIMIT = 0x40
TIC_SETTING_STEP_MODE = 0x41
TIC_SETTING_DECAY_MODE = 0x42
TIC_SETTING_STARTING_SPEED = 0x43
TIC_SETTING_MAX_SPEED = 0x47
TIC_SETTING_MAX_DECEL = 0x4B
TIC_SETTING_MAX_ACCEL = 0x4F
TIC_SETTING_SOFT_ERROR_RESPONSE = 0x53
TIC_SETTING_SOFT_ERROR_POSITION = 0x54
TIC_SETTING_ENCODER_PRESCALER = 0x58
TIC_SETTING_ENCODER_UNLIMITED = 0x5C
TIC_SETTING_KILL_SWITCH_MAP = 0x5D
TIC_SETTING_SERIAL_RESPONSE_DELAY = 0x5E
TIC_SETTINGS_SIZE = 0x5F

TIC_BAUD_RATE_GENERATOR_FACTOR = 12000000
TIC_MAX_USB_RESPONSE_SIZE = 128
TIC_INPUT_NULL = 0xFFFF
TIC_CONTROL_PIN_COUNT = 5


class TicError(Exception):
    pass


class TicDevice:
    # Encapsulates the logic to control a tic stepper driver
    def __init__(self):
        # self.is_busy = True
        self.timeout = None
        self.version = None
        self.serial = None
        # self.log_debug = True
        self.dev = None
        self.err = None
        self.cfg = None
        self.intf = None
        self.init_defaults()
        log.debug("tic init complete")

    def close(self):
        self.dev = None
        self.init_defaults()

    def init_defaults(self):
        self.timeout = 1000
        self.version = None
        self.serial = None
        self.dev = None
        self.err = None
        self.cfg = None
        self.intf = None

    def open(self, product, serial=None, vendor=0xffb):

        devices = usb.core.find(find_all=True, idVendor=vendor, idProduct=product)
        for device in devices:
            log.debug(device.serial_number)
            if serial is None or device.serial_number == serial:
                self.dev = device
                exit  # we take the first unit that matches if no serial number supplied

        if self.dev is None:
            raise TicError('tic device not found.')
        else:
            log.debug("tic open complete. Serial:" + self.dev.serial_number)

        self.dev.set_configuration()
        self.cfg = self.dev[0]
        self.intf = self.cfg[(0, 0)]
        self.serial = self.dev.serial_number

    # Could you please activate the PYUSB_DEBUG=debug and LIBUSB_DEBUG=3
    # environment variables and send the output?
    # Sorry for the delay. According to libusb documentation, a pipe error
    # is related to sending a control request not supported by the device.
    # 3Are these control transfers documented by the manufacturer or part of
    # 3the USB class spec?

    # the defaults work for the majority of tic commands
    def transfer(self, request_type=0x40, request=0, value=0, index=0, data_or_length=0, timeout=None, msg=""):
        if self.dev is None:
            raise TicError("Device not connected")
        log.debug(
            "tic" + self.serial + " - " + msg + " Req:" + hex(request) + " Val:" + str(value) + " Ind:" + str(index))
        if timeout is None:
            timeout = self.timeout
        try:
            self.dev.ctrl_transfer(bmRequestType=request_type,
                                   bRequest=request,
                                   wValue=value,
                                   wIndex=index,
                                   data_or_wLength=data_or_length,
                                   timeout=timeout)
        except:
            log.error(msg)
            pass

    def transfer_quick(self, cmd, msg=""):
        self.transfer(request=cmd, msg=msg)

    def transfer_7bit(self, cmd, data, msg=""):
        # 7-bit write command
        self.transfer(request=cmd, value=data, msg=msg)

    def transfer_32bit(self, cmd, data, msg=""):
        # 32-bit write command
        # todo validate
        value = data & 0xFFFF
        index = data >> 16 & 0xFFFF
        self.transfer(request=cmd, value=value, index=index, msg=msg)

    def transfer_block(self, cmd, data, msg=""):
        transfer(bmRequestType=40, bRequest=cmd, wValue=value, wIndex=index, data_or_wLength=None, timeout=self.timeout)
        # reads a block of data from the Tic; the block starts from the specified offset and can have a variable length

    # thin wrappers around the USB access code
    def x_set_setting_byte(self, address, byte):
        self.transfer(request=TIC_CMD_SET_SETTING, value=address, index=byte, msg="applying settings")

    def x_tic_get_setting_segment(self, index, length, output):
        assert (handle is not None)
        assert (output is not None)
        # assert(length && length <= TIC_MAX_USB_RESPONSE_SIZE);
        # size_t transferred;
        # elf.transfer(self.handle, 0xC0, TIC_CMD_GET_SETTING, 0, index, output, length, &transferred));
        # if (transferred != length) raise TicError ( "Failed to read settings.  Expected %u bytes, got %u.\n",
        # (unsigned int)length, (unsigned int)transferred);
        # return None;

    # usb tic commands - anything issued via a tic command is volatile

    def reinitialize(self):
        self.transfer_quick(TIC_CMD_REINITIALIZE,
                            msg="reinitializing the device.")

    def start_bootloader(self):
        self.transfer_quick(TIC_CMD_START_BOOTLOADER,
                            msg="starting the bootloader.")

    def set_target_position(self, position):
        self.transfer_32bit(TIC_CMD_SET_TARGET_POSITION,
                            position,
                            msg="setting the target position.")

    def set_target_velocity(self, velocity):
        self.transfer_32bit(TIC_CMD_SET_TARGET_VELOCITY,
                            velocity,
                            msg="setting the target velocity.")

    def halt_and_set_position(self, position):
        self.transfer_32bit(TIC_CMD_HALT_AND_SET_POSITION,
                            position,
                            msg="halting and setting the position.")

    def halt_and_hold(self):
        self.transfer_quick(TIC_CMD_HALT_AND_HOLD,
                            msg="halting.")

    def reset_command_timeout(self):
        self.transfer_quick(TIC_CMD_RESET_COMMAND_TIMEOUT,
                            msg="resetting the command timeout.")

    def deenergize(self):
        self.transfer_quick(TIC_CMD_DEENERGIZE,
                            msg="deenergizing.")

    def energize(self):
        self.transfer_quick(TIC_CMD_ENERGIZE,
                            msg="energizing.")

    def exit_safe_start(self):
        self.transfer_quick(TIC_CMD_EXIT_SAFE_START,
                            msg="exiting safe start.")

    def enter_safe_start(self):
        self.transfer_quick(TIC_CMD_ENTER_SAFE_START,
                            msg="entering safe start.")

    def reset(self):
        self.transfer_quick(TIC_CMD_RESET,
                            msg="sending the Reset command.")

    def clear_driver_error(self):
        self.transfer_quick(TIC_CMD_CLEAR_DRIVER_ERROR,
                            msg="clearing the driver error.")

    def set_max_speed(self, max_speed):
        self.transfer_32bit(TIC_CMD_SET_MAX_SPEED,
                            max_speed,
                            msg="setting the maximum speed.")

    def set_starting_speed(self, starting_speed):
        self.transfer_32bit(TIC_CMD_SET_STARTING_SPEED,
                            starting_speed,
                            msg="setting the starting speed.")

    def set_max_accel(self, max_accel):
        self.transfer_32bit(TIC_CMD_SET_MAX_ACCEL,
                            max_accel,
                            msg="setting the maximum acceleration.")

    def set_max_decel(self, max_decel):
        self.transfer_32bit(TIC_CMD_SET_MAX_DECEL,
                            max_decel,
                            msg="setting the maximum deceleration.")

    def set_step_mode(self, step_mode):
        self.transfer_7bit(TIC_CMD_SET_STEP_MODE,
                           step_mode,
                           "setting the step mode.")

    def set_decay_mode(self, decay_mode):
        self.transfer_7bit(TIC_CMD_SET_DECAY_MODE,
                           decay_mode,
                           msg="setting the decay mode.")

    def set_current_limit(self, value):
        milliamps = round(value / TIC_CURRENT_LIMIT_UNITS_MA)
        self.transfer_7bit(TIC_CMD_SET_CURRENT_LIMIT,
                           milliamps,
                           msg="setting the current limit.")

    def get_firmware_version_string(self):
        log.debug("fuck")
        # Initial part, e.g. "99.99": up to 5 bytes
        # Modification string: up to 127 bytes
        # Null terminator: 1 byte
